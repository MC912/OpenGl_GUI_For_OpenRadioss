#include "io/RadFileWriter.h"
#include "core/Model.h"
#include "core/Node.h"
#include "core/Element.h"
#include "core/Material.h"
#include "utils/Logger.h"
#include <iomanip>
#include <ctime>

RadFileWriter::RadFileWriter(Model* model) 
    : m_Model(model) {
}

bool RadFileWriter::Write(const std::string& filepath) {
    m_File.open(filepath);
    if (!m_File.is_open()) {
        LOG_ERROR("Cannot create file: {}", filepath);
        return false;
    }
    
    LOG_INFO("Writing RAD file: {}", filepath);
    
    WriteHeader();
    WriteNodes();
    WriteElements();
    WriteMaterials();
    WriteProperties();
    WriteBoundaryConditions();
    WriteLoads();
    
    m_File << "/END" << std::endl;
    m_File.close();
    
    LOG_INFO("Successfully wrote {} nodes, {} elements", 
             m_Model->GetNodeCount(), m_Model->GetElementCount());
    
    return true;
}

void RadFileWriter::WriteHeader() {
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    
    WriteComment("OpenRadioss Input Deck");
    WriteComment("Generated by OpenRadioss Pre-Processor");
    m_File << "#" << std::put_time(&tm, "%Y-%m-%d %H:%M:%S") << std::endl;
    m_File << "#" << std::endl;
    
    m_File << "/TITLE" << std::endl;
    m_File << "Model exported from OpenRadioss Pre-Processor" << std::endl;
}

void RadFileWriter::WriteNodes() {
    if (m_Model->GetNodeCount() == 0) return;
    
    WriteComment("NODES");
    m_File << "/NODE" << std::endl;
    
    for (const auto& node : m_Model->GetNodes()) {
        m_File << std::setw(10) << node.id
               << std::setw(20) << std::scientific << std::setprecision(10) << node.position.x
               << std::setw(20) << std::scientific << std::setprecision(10) << node.position.y
               << std::setw(20) << std::scientific << std::setprecision(10) << node.position.z
               << std::endl;
    }
}

void RadFileWriter::WriteElements() {
    if (m_Model->GetElementCount() == 0) return;
    
    // Group elements by type
    std::unordered_map<ElementType, std::vector<const Element*>> elementsByType;
    
    for (const auto& element : m_Model->GetElements()) {
        elementsByType[element.type].push_back(&element);
    }
    
    // Write each element type
    for (const auto& [type, elements] : elementsByType) {
        std::string typeStr = Element::TypeToString(type);
        WriteComment(typeStr + " ELEMENTS");
        m_File << "/" << typeStr << "/" << std::endl;
        
        for (const auto* element : elements) {
            m_File << std::setw(10) << element->id;
            for (int nodeId : element->nodeIds) {
                m_File << std::setw(10) << nodeId;
            }
            m_File << std::endl;
        }
    }
}

void RadFileWriter::WriteMaterials() {
    if (m_Model->GetMaterialCount() == 0) return;
    
    WriteComment("MATERIALS");
    
    // Write elastic materials
    for (const auto& material : m_Model->GetMaterials()) {
        if (material.type == MaterialType::ELASTIC) {
            m_File << "/MAT/ELAST/1/" << material.id << std::endl;
            m_File << material.name << std::endl;
            m_File << std::setw(20) << std::scientific << material.density
                   << std::setw(20) << std::scientific << material.youngModulus
                   << std::endl;
            m_File << std::setw(20) << std::scientific << material.poissonRatio
                   << std::endl;
        }
        else if (material.type == MaterialType::JOHNSON_COOK) {
            m_File << "/MAT/JOHN_COOK/2/" << material.id << std::endl;
            m_File << material.name << std::endl;
            // Write Johnson-Cook parameters...
        }
    }
}

void RadFileWriter::WriteBoundaryConditions() {
    WriteComment("BOUNDARY CONDITIONS");
    // TODO: Write boundary conditions
}

void RadFileWriter::WriteLoads() {
    WriteComment("LOADS");
    // TODO: Write loads
}

void RadFileWriter::WriteComment(const std::string& comment) {
    m_File << "#" << std::endl;
    m_File << "# " << comment << std::endl;
    m_File << "#" << std::endl;
}